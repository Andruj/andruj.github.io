<html><head><title>Andrew Peterson</title><link href="/styles/bootstrap.min.css" rel="stylesheet"/><link href="/styles/prism.css" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Raleway|Anonymous+Pro:400,700" rel="stylesheet" type="text/css"/><link href="/styles/index.css" rel="stylesheet"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/></head><body id="article" class="container"><article class="row"><div class="col-xs-12"><h1>Creating a Restful API with Koa 2</h1>
<h6>author: <a href="https://twitter.com/andrwpeterson">@andrewwpeterson</a></h6>
<h6>date: 2015.02.03</h6>
<hr>
<h4>Overview</h4>
<p>So I recently moved from Express to Koa, and already loving it, thought there
would be some useful things to share. Keep in mind, Koa 2 isn't out yet,
but it works pretty easily with babel.</p>
<p>So Koa 2.0 moves away from generator functions (the asterisk thing with yield)
and moves to a much cooler, async/await bidirectional server. If you are wondering
what that means, or if you are wondering what is one of the main differences
between Koa and Express, then listen up. In Express, the server works in one
direction. In Koa, it works in two directions, fundamentally different from
Express. Read more about that in this this
<a href="https://github.com/koajs/koa/blob/master/docs/koa-vs-express.md">Koa vs. Express article</a>.</p>
<p>Also, one of my main draws to Koa is their usage of ES2015 and ES7 technologies.
So today I wanted to use those technologies in par with the Mongoose ORM to show
how expressive and powerful Koa can be. Or just show you what I picked up on. Either or.</p>
<p>For this article you should roughly know about:</p>
<ul>
<li>Promises</li>
<li>Async / await</li>
<li>Express</li>
<li>Mongoose</li>
</ul>
<h4>Getting Started</h4>
<p>Koa provides some generators for their projects, much like the express-generator
module, however I did not use that. I am not going to walk you through each step,
but more focus on how the framework, well, works. Keep in mind you have to run
<code>npm install --save koa@next</code> to get the Koa 2.0 (as of 2015.02.03)</p>
<p>So lets make our basic example.</p>
<pre><code class="language-javascript">// 'babel-polyfill' is needed for async/await.
import 'babel-polyfill';
import Koa from 'koa';

// Create the app from the ES6 class.
const app = new Koa();

app.use(async (ctx, next) =&gt; ctx.body = 'Hello World');

// Start the application.
app.listen(5050, () =&gt; console.log('Listening on port 5050.'));

export default app;
</code></pre>
<p>Now if you run this after transpiling it with babel, and go to
<a href="localhost:5050">localhost:5050</a>, you should see 'Hello World'</p>
<p>But that isn't very helpful, and not even close to a full Mongo-REST api.
If you come from an Express background, here is what you might be used to.</p>
<pre><code class="language-javascript">var express = require('express');
var app = express();

app.get('/', function (req, res) {
  res.send('Hello World!');
});

app.listen(3000, function () {
  console.log('Example app listening on port 3000!');
});
</code></pre>
<p>By setting the <code>ctx.body</code> variable, you are accessing <code>ctx.request.body</code>
which is what is displayed to the user. Basically, the context is what you
mess with and alter. Notice how Express requires you to specify '/' as your
route, while Koa does not. I will go over how to make universal interceptors
for logging or pre-processing in a bit.</p>
<h3>Adding the REST</h3>
<p>No pun intended.
So let's make our simple application more advanced.</p>
<pre><code class="language-javascript">// App.js
import Koa from 'koa';
import mongoose from 'mongoose';
// Middleware for routing.
import middleware from 'koa-router';
// Middleware for logging pretty messages.
import logger from 'koa-logger';
// Middleware for accesing json from ctx.body.
import parser from 'koa-bodyparser';
// A seperate file with my routes.
import routing from './routing';

// Mongoose init code.
mongoose.connect('mongodb://localhost/testapp');
mongoose.connection.on('error', console.error);

// Applies all routes to the router.
const router = routing(middleware());
// Creates the application.
const app = new Koa();

app
  .use(logger()) // Logs information.
  .use(parser()) // Parses json body requests.
  // A universal interceptor, that prints the ctx each time a request
  // is made on the server.
  .use(async function(ctx, next) {
    console.log(ctx);
    return await next();
  })
  .use(router.routes()) // Assigns routes.
  .use(router.allowedMethods())

// Start the application.
app.listen(5050, () =&gt; console.log('Listening on port 5050.'));

export default app;
</code></pre>
<p>Wow this is a lot of code. So basically, there are 3 important modules I added
alongside Koa, which are koa-router, allowing us to link our async functions to
the server, koa-bodyparser, which is similar to the bodyParser module from Express,
giving us access to JSON data, and koa-logger, which logs all the requests.</p>
<p>I wanted this example to be realistic, so I defined my routes in a different
file, which I pass in the router created from <code>middleware()</code>. It returns the
router after modifying it with the various routes for our REST server.
So we apply the middleware with <code>app.use(logger())</code> and <code>app.use(parser())</code>.</p>
<p>Throught my minimal time with Koa, I figured out how to create a global
interceptor, which is the async function I defined. All it does is log the
<code>ctx</code> object, but it illustrates the example nonetheless.</p>
<p><code>app.use(router.routes())</code> is similar to Express' router, which binds the
Koa app to the routes we set up.</p>
<p>Let's take a look at the routes file.</p>
<pre><code class="language-javascript">const api = 'locations';
// Export a function that takes the router
export default router =&gt; {
  // Set a prefix of our api, in this case locations
  const api = 'locations'
  router.prefix(`/${api}`);

  // GET to all locations.
  router.get('/', async (ctx, next) =&gt;
    ctx.body = await Location.find());
  // POST a new location.
  router.post('/', async (ctx, next) =&gt;
    ctx.body = await new Location(ctx.request.body).save());
  // Routes to /locations/id.
  router.get('/:id', async (ctx, next) =&gt;
    ctx.body = await Location.findById(ctx.params.id));
  // PUT to a single location.
  router.put('/:id', async (ctx, next) =&gt;
    ctx.body = await Location.findByIdAndUpdate(ctx.params.id, ctx.body));
  // DELETE to a single location.
  router.delete('/:id', async (ctx, next) =&gt;
    ctx.body = await Location.findByIdAndRemove(ctx.params.id));

  return router;
}
</code></pre>
<p>I used the ES2015 arrow functions to show exactly how expressive this could be.
NOW IDEALLY, you would wrap those <code>await</code>s in a nice <code>try/catch</code> block. The
point I am trying to make is to show just how minimal it can be. So now if you
do a GET request to localhost:5050/locations you will get all your locations!
One of the nice features of Mongoose 4.0 is that they return promises, which means
they work perfectly with async / await.</p>
<p>So in 25 lines of code (could be if in one file), we can create a REST api. I
think that Express has a ton of validity and has grounded NodeJS
in modern web application development, however, Koa is sure pushing forward
with the new technologies. And man, it is cool.</p>
<p>I condensed the minimal code to a single file. 21 lines of lovely, unreadable JavaScript.</p>
<pre><code class="language-javascript">// App.js
import Koa from 'koa';
import mongoose from 'mongoose';
import middleware from 'koa-router';
import logger from 'koa-logger';
import parser from 'koa-bodyparser';

mongoose.connect('mongodb://localhost/testapp');
mongoose.connection.on('error', console.error);

const router = middleware();
const app = new Koa();

router.get('/locations', async (ctx, next) =&gt;  ctx.body = await Location.find());
router.post('/locations', async (ctx, next) =&gt;  ctx.body = await new Location(ctx.request.body).save());
router.get('/locations/:id', async (ctx, next) =&gt;  ctx.body = await Location.findById(ctx.params.id));
router.put('/locations/:id', async (ctx, next) =&gt;  ctx.body = await Location.findByIdAndUpdate(ctx.params.id, ctx.body));
router.delete('/locations/:id', async (ctx, next) =&gt;  ctx.body = await Location.findByIdAndRemove(ctx.params.id));
app
  .use(logger()) // Logs information.
  .use(parser()) // Parses json body requests.
  .use(router.routes()) // Assigns routes.
  .use(router.allowedMethods())

app.listen(5050, () =&gt; console.log('Listening on port 5050.'));
export default app;
</code></pre>
<h3>About Me</h3>
<p>Hi! I am Andrew Peterson, and if you got all the way down here, hopefully you
learned something. I am super passionate about JavaScript, Dart, Angular and
anything having to do with Front-End Development. Message me if you have any feedback, <a href="https://twitter.com/andrwpeterson">@andrewwpeterson</a>. These articles are not designed to be full walk-throughs, or even complete, but more of a stepping stone in places I realized there was not a lot of information.</p>
</div></article><script src="/scripts/prism.js"></script></body></html>